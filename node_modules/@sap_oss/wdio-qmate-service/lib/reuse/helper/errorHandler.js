"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QmateError = void 0;
const errorMessages_1 = require("../helper/errorMessages");
var Modules;
(function (Modules) {
    Modules["Node_modules"] = "node_modules";
    Modules["Node"] = "node";
    Modules["Mocha"] = "mocha";
})(Modules || (Modules = {}));
class QmateError extends Error {
    constructor(message, displayStack) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        this.stack = displayStack ? this._getFormattedStackTrace(this.stack) : "";
    }
    // =================================== HELPER ===================================
    _getFormattedStackTrace(stack) {
        if (stack) {
            var stackTrace = stack
                .split("\n")
                .map((line) => {
                return line.includes("ErrorHandler.logException") ? "" : line;
            })
                .filter(Boolean)
                .join("\n");
            return stackTrace;
        }
        else {
            return "";
        }
    }
}
exports.QmateError = QmateError;
class ErrorHandler {
    logException(errorObject, customErrorMessage, logStackTrace = true) {
        if (errorObject instanceof Error) {
            let functionName = this._retrieveLastLevelFunctionNameFromStack(errorObject);
            if (customErrorMessage) {
                let errorMessage = errorMessages_1.ErrorMessages.customErrorWithMessage(functionName, this._formatStackMessage(customErrorMessage));
                throw new QmateError(errorMessage, logStackTrace);
            }
            else if (errorObject.message) {
                let errorMessage = errorMessages_1.ErrorMessages.customErrorWithMessage(functionName, this._formatStackMessage(errorObject.message));
                throw new QmateError(errorMessage, logStackTrace);
            }
            else {
                throw new QmateError(errorMessages_1.ErrorMessages.customErrorWithoutMessage(functionName), logStackTrace);
            }
        }
        else {
            throw new QmateError(errorMessages_1.ErrorMessages.genericErrorMessage(), logStackTrace);
        }
    }
    // =================================== HELPER ===================================
    _retrieveLastLevelFunctionNameFromStack(errorObject) {
        if (errorObject instanceof Error && errorObject.stack) {
            const regex = /\bat\s*(.+?)\(/;
            let functionName = "block";
            let initFunctionArray = [];
            let errorStackAfterSplit = errorObject.stack.split("\n");
            for (let i = 0, index = 0; i < errorStackAfterSplit.length; i++) {
                let matchedString = !this._isThirdPartyModuleIncludedInStack(errorStackAfterSplit[i]) && errorStackAfterSplit[i].match(regex);
                if (matchedString) {
                    initFunctionArray[index] = matchedString[1].trim();
                    if (initFunctionArray[index].includes("anonymous")) {
                        index = index - 1;
                        functionName =
                            index < 0
                                ? functionName
                                : initFunctionArray[index].includes(".")
                                    ? initFunctionArray[index].substring(initFunctionArray[index].indexOf(".") + 1)
                                    : initFunctionArray[index];
                    }
                    index++;
                }
            }
            return functionName;
        }
        else {
            return "";
        }
    }
    _isThirdPartyModuleIncludedInStack(line) {
        if (line) {
            let module = Object.values(Modules);
            for (let i = 0; i < module.length; i++) {
                if (line.toLowerCase().trim().includes(module[i])) {
                    return true;
                }
            }
        }
        return false;
    }
    _formatStackMessage(errorMessage) {
        errorMessage = errorMessage.trim();
        return errorMessage.match(/\b(Function|function)\s*'([a-zA-Z_-]*)'\s*failed with\s*\b:/)
            ? errorMessage.replaceAll(errorMessage.substring(0, errorMessage.indexOf(":") + 1), "").trim()
            : errorMessage;
    }
}
exports.default = ErrorHandler;
//# sourceMappingURL=errorHandler.js.map