"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UI5ControlHandler = void 0;
const ControlFinder_1 = require("../utils/ControlFinder");
const LocatorDebug_1 = require("../utils/LocatorDebug");
class UI5ControlHandler {
    static retrieveValidUI5ControlsSubElements(nodes) {
        if (!nodes || nodes.length === 0) {
            return [];
        }
        const aCandidateControls = [];
        Array.prototype.forEach.call(nodes, (node) => {
            const nodeId = node.getAttribute("id");
            const control = ControlFinder_1.ControlFinder.getUI5Control(nodeId);
            if (control) {
                aCandidateControls.push(control);
            }
            else {
                aCandidateControls.push(...UI5ControlHandler.retrieveValidUI5ControlsSubElements(node.children));
            }
        });
        return aCandidateControls;
    }
    static extractBindingPathAndModelProperty(pathObj) {
        const binding = {
            model: "",
            path: ""
        };
        if (!pathObj?.path)
            return binding;
        binding.path = pathObj.path;
        if (pathObj.path.indexOf(">") !== -1) {
            binding.model = pathObj.path.substring(0, pathObj.path.indexOf(">"));
            binding.path = pathObj.path.substring(pathObj.path.indexOf(">") + 1, pathObj.path.length);
        }
        return binding;
    }
    static findSiblingControls(control) {
        const parentControl = UI5ControlHandler.getUI5Parent(control);
        const parentId = parentControl?.getId?.();
        const controlId = control?.getId?.();
        if (!parentControl || !parentId || !controlId) {
            return [];
        }
        const parentElement = document.getElementById(parentId);
        if (!parentElement) {
            return [];
        }
        const allSiblingNodes = parentElement.children;
        const aValidControls = UI5ControlHandler.retrieveValidUI5ControlsSubElements(allSiblingNodes);
        if (!aValidControls || aValidControls.length === 0)
            return [];
        const controlIndx = aValidControls.findIndex((element) => element.getId() === controlId);
        if (controlIndx === -1) {
            throw new Error("Something is very wrong with prev/next control finder");
        }
        else {
            aValidControls.splice(controlIndx, 1);
            return aValidControls;
        }
    }
    static findPreviousOrNextControl(control, bIsNext) {
        const oParentControl = UI5ControlHandler.getUI5Parent(control);
        const sControlId = control?.getId?.();
        const sParentId = oParentControl?.getId?.();
        if (!oParentControl || !sParentId || !sControlId)
            return null;
        const parentElement = document.getElementById(sParentId);
        if (!parentElement)
            return null;
        const aAllSiblingNodes = parentElement.children;
        const aValidControls = UI5ControlHandler.retrieveValidUI5ControlsSubElements(aAllSiblingNodes);
        const controlIndx = aValidControls.findIndex((element) => element.getId() === sControlId);
        if (controlIndx === -1) {
            console.error("Something is very wrong with prev/next control finder");
        }
        if (bIsNext && aValidControls.length - 1 > controlIndx) {
            return aValidControls[controlIndx + 1];
        }
        else if (!bIsNext && controlIndx > 0) {
            return aValidControls[controlIndx - 1];
        }
        return null;
    }
    static getControlBindingContextPaths(control) {
        if (!control)
            return [];
        // Merge all possible binding context sources
        const bindingContexts = Object.assign({}, control.oPropagatedProperties?.oBindingContexts, control.oBindingContexts, control.mElementBindingContexts);
        return Object.values(bindingContexts)
            .filter((value) => !!value && value.getPath && typeof value.getPath === "function")
            .map((ctx) => ctx.getPath())
            .filter((path) => path);
    }
    // first navigate up the DOM tree to find the UI5 parent element
    // if none is found try with the ui5 getParent method
    // if none is found return undefined
    static getUI5Parent(control) {
        let domParent = document.getElementById(control.getId?.())?.parentElement;
        while (true) {
            if (!domParent)
                return control.getParent?.();
            const oParentControl = ControlFinder_1.ControlFinder.getUI5Control(domParent.getAttribute("id"));
            if (oParentControl) {
                return oParentControl;
            }
            domParent = domParent.parentElement;
        }
    }
    static getControlProperty(control, propKey) {
        if (!control || !propKey)
            return undefined;
        const metadata = control.getMetadata?.();
        const property = metadata?.getProperty?.(propKey);
        const aggregation = metadata?.getAggregation?.(propKey);
        const association = metadata?.getAssociation?.(propKey);
        return (property ?? aggregation ?? association)?.get?.(control);
    }
    static getControlAllProperties(control) {
        return {
            ...control?.getMetadata?.()?.getAllProperties?.(),
            ...control?.getMetadata?.()?.getAllAssociations?.(),
            ...control?.getMetadata?.()?.getAllAggregations?.()
        };
    }
    static getBindDataForProperty(control, propKey) {
        const aProperties = UI5ControlHandler.getControlAllProperties(control);
        if (aProperties.hasOwnProperty(propKey)) {
            return UI5ControlHandler.getBindingInfos(control, propKey);
        }
        return [];
    }
    static createBindingInfo(part) {
        return {
            model: part.model || "",
            path: part.path || "",
            value: ""
        };
    }
    static getBindingInfos(control, propKey) {
        const bindingInfo = control.getBindingInfo?.(propKey);
        if (!bindingInfo)
            return [];
        const parts = (bindingInfo.parts ?? []);
        const infos = [];
        infos.push(...parts.filter((part) => part.path).map(UI5ControlHandler.createBindingInfo));
        if (infos.length === 0 && bindingInfo.path) {
            infos.push(UI5ControlHandler.createBindingInfo(bindingInfo));
        }
        const binding = control.getBinding?.(propKey);
        if (binding && infos.length > 0) {
            UI5ControlHandler.retrieveCompositeBindings(binding, infos);
        }
        return infos;
    }
    static retrieveCompositeBindings(binding, bindingInfos) {
        if (binding.getBindings) {
            const subBindings = binding.getBindings() ?? [];
            subBindings.forEach((subBinding) => UI5ControlHandler.retrieveCompositeBindings(subBinding, bindingInfos));
        }
        else if (binding.getPath && binding.getValue) {
            const info = bindingInfos.find((bi) => bi.path === binding.getPath());
            if (info) {
                info.value = binding.getValue();
            }
        }
    }
    static getUI5Ancestors(control) {
        const MAXIMUM_DEPTH = 500;
        const ancestors = [];
        let parentControl = UI5ControlHandler.getUI5Parent(control);
        const visited = new Set();
        visited.add(control);
        while (parentControl && !visited.has(parentControl) && ancestors.length < MAXIMUM_DEPTH) {
            ancestors.push(parentControl);
            visited.add(parentControl);
            parentControl = UI5ControlHandler.getUI5Parent(parentControl);
        }
        if (ancestors.length >= MAXIMUM_DEPTH) {
            LocatorDebug_1.LocatorDebug.debugLog("Maximum depth reached while retrieving ancestors for control", control.getId?.());
        }
        LocatorDebug_1.LocatorDebug.debugLog("found ancestors:" + ancestors.length);
        return ancestors;
    }
}
exports.UI5ControlHandler = UI5ControlHandler;
//# sourceMappingURL=UI5ControlHandler.js.map