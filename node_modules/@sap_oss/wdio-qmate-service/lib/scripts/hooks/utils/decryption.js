"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const qcrypt_1 = require("qcrypt");
const DEFAULT_OPTIONS = {
    useBase64Input: false,
    useBase64Output: false,
    includeRepoUrl: true
};
class Decryption {
    initDecryptFunction() {
        try {
            const privateKey = qcrypt_1.Decrypter.retrievePrivateKey(path_1.default.resolve(__dirname, "../../../.."));
            global.util.data.privateKeyFound = true;
            global.util.data.decrypt = (input, options) => {
                const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
                try {
                    return qcrypt_1.Decrypter.decryptData(input, privateKey, mergedOptions);
                }
                catch (error) {
                    if (error instanceof Error) {
                        throw new Error(`Function 'decrypt' failed: ${error.message}`);
                    }
                    else {
                        throw new Error("Function 'decrypt' failed: Unknown error");
                    }
                }
            };
        }
        catch (error) {
            global.util.data.decrypt = function () {
                throw new Error("Function 'decrypt' failed: No private key found.");
            };
        }
    }
    decryptSauceConfig(config) {
        try {
            config.user = util.data.decrypt(config.user);
        }
        catch (error) {
            // do nothing, user was not encrypted
        }
        try {
            config.key = util.data.decrypt(config.key);
        }
        catch (error) {
            // do nothing, key was not encrypted
        }
    }
}
exports.default = new Decryption();
//# sourceMappingURL=decryption.js.map