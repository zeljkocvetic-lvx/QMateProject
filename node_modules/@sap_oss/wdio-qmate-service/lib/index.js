/* eslint-disable no-console */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const beforeSession_1 = __importDefault(require("./scripts/hooks/beforeSession"));
const before_1 = __importDefault(require("./scripts/hooks/before"));
const onPrepare_1 = __importDefault(require("./scripts/hooks/onPrepare"));
const onComplete_1 = __importDefault(require("./scripts/hooks/onComplete"));
const after_1 = __importDefault(require("./scripts/hooks/after"));
const isBrowserDefined_1 = require("./scripts/hooks/utils/isBrowserDefined");
const pj = require("../package.json");
module.exports = class CustomWorkerService {
    /**
     * `serviceOptions` contains all options specific to the service
     * e.g. if defined as follows:
     *
     * ```
     * services: [['custom', { foo: 'bar' }]]
     * ```
     *
     * the `serviceOptions` parameter will be: `{ foo: 'bar' }`
     */
    // @ts-ignore
    constructor(serviceOptions, capabilities, config) {
        this._statsUsageId = null;
        this.config = config;
    }
    /**
     * Gets executed once before all workers get launched.
     * @param {Object} config wdio configuration object
     * @param {Array.<Object>} capabilities list of capabilities details
     */
    // @ts-ignore
    async onPrepare(config, capabilities) {
        const logo = `                         __     
  ____ _____ ___  ____ _/ /____ 
 / __ \`/ __ \`__ \\/ __ \`/ __/ _ \\
/ /_/ / / / / / / /_/ / /_/  __/
\\__, /_/ /_/ /_/\__,_/\\__/\\___/ 
  /_/   \x1b[3m service v.${pj.version}\x1b[0m                              
      `;
        console.log(logo);
        try {
            await (0, onPrepare_1.default)(config, capabilities, (statsUsageId) => {
                this._statsUsageId = statsUsageId;
            });
        }
        catch (e) {
            console.error(`onPrepare hook failed: ${e}`);
        }
    }
    /**
     * Gets executed just before initializing the webdriver session and test framework. It allows you
     * to manipulate configurations depending on the capability or spec.
     * @param {Object} config wdio configuration object
     * @param {Array.<Object>} capabilities list of capabilities details
     * @param {Array.<String>} specs List of spec file paths that are to be run
     */
    // @ts-ignore
    async beforeSession(config, capabilities, specs) {
        try {
            if ((0, isBrowserDefined_1.isBrowserDefined)()) {
                browser.config = config;
            }
            await (0, beforeSession_1.default)(config, capabilities, specs);
            this.config = config;
        }
        catch (e) {
            if (specs && specs[0]) {
                // `specs` variable is an array, but includes only one current spec
                console.error(`qmateLoader() in 'beforeSession' hook failed for spec '${specs[0]}'. ${e}`);
            }
            else {
                console.error(`qmateLoader() in 'beforeSession' hook failed. ${e}`);
            }
        }
    }
    /**
     * Gets executed before test execution begins. At this point you can access to all global
     * variables like `browser`. It is the perfect place to define custom commands.
     * @param {Array.<Object>} capabilities list of capabilities details
     * @param {Array.<String>} specs        List of spec file paths that are to be run
     * @param {Object}         browser      instance of created browser/device session
     */
    // @ts-ignore
    async before(capabilities, specs, browser) {
        // Errors in WDIO hooks are suppressed by default => we call process.exit(1). It will mark all specs as failed
        try {
            browser.config = this.config;
            browser.params = browser.config.params;
            await (0, before_1.default)(capabilities, specs, browser);
        }
        catch (e) {
            if (specs && specs[0]) {
                // `specs` variable is an array, but includes only one current spec
                util.console.error(`qmateLoader() in 'before' hook failed for spec '${specs[0]}'. ${e}`);
            }
            else {
                util.console.error(`qmateLoader() in 'before' hook failed. ${e}`);
            }
        }
    }
    /**
     * Gets executed before the suite starts.
     * @param {Object} suite suite details
     */
    async beforeSuite(suite) {
        util.console.log(` ${suite.fullTitle}  `, "black", "white");
    }
    /**
     * Function to be executed after a test (in Mocha/Jasmine)
     */
    // @ts-ignore
    async afterTest(test, context, { error, result, duration, passed, retries }) {
        // test.title - for mocha framework
        // test.description - for jasmine framework
        const testName = test.title || test.description;
        // Print test titles as in vyperForAll during test run
        if (!error && passed === true) {
            util.console.info(`\x1b[32m\t✓ ${testName}\x1b[0m  (${Math.round(duration / 1000)}s)`);
        }
        else if (error || passed !== true) {
            util.console.error(`\x1b[31m\t✗ ${testName}\x1b[0m  (${Math.round(duration / 1000)}s)`);
        }
    }
    /**
     * Gets executed after all tests are done. You still have access to all global variables from
     * the test.
     * @param {Number} result 0 - test pass, 1 - test fail
     * @param {Array.<Object>} capabilities list of capabilities details
     * @param {Array.<String>} specs List of spec file paths that ran
     */
    async after(result, capabilities, specs) {
        try {
            await (0, after_1.default)(result, capabilities, specs);
        }
        catch (e) {
            util.console.error(`after hook failed: ${e}`);
        }
    }
    /**
     * Gets executed after all workers have shut down and the process is about to exit.
     * An error thrown in the `onComplete` hook will result in the test run failing.
     * @param {Object} exitCode 0 - success, 1 - fail
     * @param {Object} config wdio configuration object
     * @param {Array.<Object>} capabilities list of capabilities details
     * @param {<Object>} results object containing test results
     */
    async onComplete(exitCode, config, capabilities, results) {
        try {
            await (0, onComplete_1.default)(exitCode, config, capabilities, results, this._statsUsageId);
        }
        catch (e) {
            util.console.error(`onComplete hook failed: ${e}`);
        }
    }
};
//# sourceMappingURL=index.js.map